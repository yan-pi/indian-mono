# AI Development Guidelines for BR2 Consulting Monorepo

## Project Architecture Overview

The BR2 Consulting monorepo follows a structured approach to web development, combining Payload CMS for content management with a Next.js frontend. The architecture enables content editors to build pages dynamically by assembling blocks through the CMS interface.

### Repository Structure

```
br2-mono/
├── apps/
│   ├── admin/     # Payload CMS for content management
│   └── web/       # Next.js client-facing website
│       ├── app/                # Next.js app router pages
│       ├── components/         # React components
│       │   ├── blocks/         # CMS-configurable content blocks
│       │   ├── page-builder/   # Dynamic page rendering system
│       │   └── sections/       # Hardcoded page sections
│       └── lib/
│           └── api-client/     # API client utilities with React Query
├── packages/
│   ├── eslint-config/     # Shared ESLint configurations
│   ├── typescript-config/ # Shared TypeScript configurations
│   └── ui/                # Shadcn UI component library
```

## Content Management System

### Pages Collection

The heart of the system is the `Pages` collection in Payload CMS (`apps/admin/src/collections/Pages.ts`). This collection allows content editors to:

1. Create pages with metadata (title, slug, template)
2. Build page layouts by adding configurable blocks
3. Create page hierarchies with parent-child relationships
4. Control page visibility with status fields

### Dynamic Page Building

Pages are constructed using a layout array containing block objects. Each block has:

- `blockType`: Identifier corresponding to a component in the frontend
- Various properties specific to that block type
- Optional `blockName` for identification in the CMS

## Development Workflow

### Adding a New Block Type

To implement a new content block that can be used in the CMS, follow these steps:

#### 1. Define the Block Schema in Payload CMS

In `apps/admin/src/collections/Pages.ts`, add a new block definition to the `blocks` array:

```typescript
{
  slug: 'myNewBlock',
  imageAltText: 'Description for admin UI',
  fields: [
    {
      name: 'title',
      type: 'text',
      label: 'Title',
      required: true,
    },
    {
      name: 'content',
      type: 'richText',
      label: 'Content',
    },
    // Add other fields as needed
  ],
}
```

#### 2. Create the React Component

Create a new file in `apps/web/components/blocks/` (e.g., `my-new-block.tsx`):

```tsx
"use client";

import { FC } from "react";
import { renderField } from "../../lib/utils/cms-renderer";

interface MyNewBlockProps {
  title?: string;
  content?: any;
  // Add other props that match your schema
}

const MyNewBlock: FC<MyNewBlockProps> = ({ title, content }) => {
  return (
    <section className="container mx-auto py-12">
      {title && (
        <h2 className="text-3xl font-bold mb-4">{renderField(title)}</h2>
      )}
      {content && (
        <div className="prose max-w-none">{renderField(content)}</div>
      )}
    </section>
  );
};

export default MyNewBlock;
```

#### 3. Register the Component in the Block Index

Update `apps/web/components/blocks/index.tsx` to include your new component:

```typescript
import MyNewBlock from "./my-new-block";

type BlockComponentsMap = {
  // Existing components...
  myNewBlock: typeof MyNewBlock;
};

export const blockComponents: BlockComponentsMap = {
  // Existing mappings...
  myNewBlock: MyNewBlock,
};
```

#### 4. Update TypeScript Types (Optional)

The system will work without this step, but for better type safety, you can update the types in `apps/admin/src/payload-types.ts` (this file is automatically generated when running Payload).

### Data Flow

1. **Content Creation**:

   - Admin creates/edits a page in Payload CMS
   - Adds and configures blocks in the page layout

2. **Data Fetching**:

   - Next.js frontend requests page data via API client
   - React Query manages caching and state

3. **Rendering**:
   - `PageBuilder` component receives the page layout array
   - Maps each block to its component using the `blockComponents` registry
   - Passes block data as props to the component

## Block Component Best Practices

### Component Structure

1. **Use `"use client"` directive** when components use React hooks or browser APIs

2. **Define clear interfaces** that match the Payload schema fields:

   ```tsx
   interface CtaCardProps {
     title?: string;
     text?: string;
     primaryButtonText?: string;
     primaryButtonLink?: string;
     // etc.
   }
   ```

3. **Use renderField utility** to handle content from Payload:

   ```tsx
   {
     title && <h2 className="text-3xl font-bold">{renderField(title)}</h2>;
   }
   ```

4. **Provide sensible defaults** for optional props:

   ```tsx
   const CtaCard: FC<CtaCardProps> = ({
     title = "Pronto para começar?",
     text = "Entre em contato para saber como podemos ajudar.",
     // other defaults...
   }) => {
     /* ... */
   };
   ```

5. **Handle conditional rendering** based on provided data:
   ```tsx
   {
     secondaryButtonText && (
       <Button variant="outline" asChild>
         <a href={secondaryButtonLink}>{renderField(secondaryButtonText)}</a>
       </Button>
     );
   }
   ```

### Styling Guidelines

1. **Follow Tailwind CSS conventions** for styling

   - Use utility classes for layout and spacing
   - Create consistent spacing patterns (e.g., `py-12`)

2. **Leverage UI components** from the shared package:

   ```tsx
   import { Button } from "ui/components/ui/button";
   import { Card, CardContent } from "ui/components/ui/card";
   ```

3. **Handle responsive design**:
   ```tsx
   <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
   ```

### API Data Fetching

1. **Create dedicated hooks** in the `lib/api-client` directory:

   ```tsx
   export const usePageByPath = (path: string) => {
     return useQuery({
       queryKey: ["page", path],
       queryFn: async (): Promise<Page | null> => {
         // API implementation
       },
       staleTime: 1000 * 60 * 5, // 5 minutes
     });
   };
   ```

2. **Handle loading and error states**:

   ```tsx
   const { data, isLoading, error } = usePageByPath(fullPath);

   if (isLoading) return <LoadingComponent />;
   if (error) return <ErrorComponent />;
   if (!data) return <NotFoundComponent />;
   ```

## Examples for Common Tasks

### Creating a Card Grid Block

1. **Payload Schema Definition**:

```typescript
{
  slug: 'cardGrid',
  imageAltText: 'Grade de cartões',
  fields: [
    {
      name: 'title',
      type: 'text',
      label: 'Título',
    },
    {
      name: 'cards',
      type: 'array',
      label: 'Cartões',
      fields: [
        {
          name: 'cardTitle',
          type: 'text',
          label: 'Título',
          required: true,
        },
        // More fields...
      ],
    },
    // More configuration fields...
  ],
}
```

2. **React Component Implementation**:

```tsx
const CardGrid: FC<CardGridBlockProps> = ({
  title,
  subtitle,
  cards = [],
  columns = 3,
  showShadow = true,
}) => {
  return (
    <div className="container mx-auto py-12">
      {/* Title section */}
      {(title || subtitle) && (
        <div className="text-center mb-8">
          {title && <h2 className="text-3xl font-bold mb-2">{title}</h2>}
          {subtitle && (
            <p className="text-lg text-muted-foreground">{subtitle}</p>
          )}
        </div>
      )}

      {/* Grid of cards */}
      <div className={`grid grid-cols-1 md:grid-cols-${columns} gap-6`}>
        {cards.map((card, index) => (
          <Card key={index} className={showShadow ? "shadow-md" : ""}>
            {/* Card content */}
          </Card>
        ))}
      </div>
    </div>
  );
};
```

### Creating a Feature Grid Block

Similar to the Card Grid but with different styling and structure.

## Static vs. Dynamic Pages

This project uses two approaches for page creation:

1. **Static Pages**: Hardcoded in the Next.js app directory (e.g., `apps/web/app/sobre/page.tsx`)

   - Used for core pages with complex requirements
   - Direct control over component structure and layout

2. **Dynamic Pages**: Rendered from Payload CMS data
   - Used for marketing pages, landing pages, and content-heavy pages
   - Configurable through the admin interface without code changes

## Testing Your Implementation

1. **Restart Payload CMS** after adding new block schemas
2. **Create a test page** in the admin panel using your new block
3. **Verify rendering** on the frontend
4. **Check responsiveness** at different screen sizes

## Summary

The development workflow in this project centers around creating modular, reusable block components that can be composed in the CMS to build pages dynamically. This approach provides flexibility for content editors while maintaining code quality and developer experience.

When adding new features, remember to:

1. Define the block schema in Payload
2. Create the corresponding React component
3. Register the component in the block component registry
4. Test thoroughly in both admin and frontend contexts
